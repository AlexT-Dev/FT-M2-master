{"version":3,"sources":["actions/index.js","components/Counter.js","reducers/index.js","index.js"],"names":["INCREMENT","DECREMENT","increment","type","decrement","Counter","incrementIfOdd","props","count","incrementAsync","setTimeout","this","onClick","Component","connect","state","initialState","store","createStore","action","ReactDOM","render","document","getElementById"],"mappings":"iLAAaA,EAAY,YACZC,EAAY,YAOZC,EAAY,WAEvB,MAAO,CACLC,KAAMH,IAIGI,EAAY,WAEvB,MAAO,CACJD,KAAMF,I,OCdLI,E,4MAEFC,eAAiB,WAEZ,EAAKC,MAAMC,MAAQ,IAAM,GAC1B,EAAKD,MAAML,a,EAIfO,eAAiB,WAEbC,WAAW,EAAKH,MAAML,UAAW,M,4CAGrC,WAGI,OACI,4CACgBS,KAAKJ,MAAMC,MAD3B,SAEI,wBAAQI,QAAS,aAAjB,gBAGA,wBAAQA,QAAS,aAAjB,iBAIA,wBAAQA,QAASD,KAAKL,eAAtB,oCAGA,wBAAQM,QAASD,KAAKF,eAAtB,sD,GA9BMI,aAqDPC,eAVS,SAACC,GACrB,MAAO,CACHP,MAAOO,EAAMP,SAQmB,CAAEN,YAAWE,aAAtCU,CAAmDT,GCvD5DW,EAAe,CACnBR,MAAO,GCSHS,EAAQC,aDHC,WAAmC,IAAlCH,EAAiC,uDAAzBC,EAAcG,EAAW,uCAC/C,OAAQA,EAAOhB,MACb,KAAKH,EAEF,MAAO,CACLQ,MAAOO,EAAMP,MAAQ,GAE1B,KAAKP,EAEH,MAAO,CACLO,MAAOO,EAAMP,MAAQ,GAEzB,QACE,OAAOO,MCJbK,IAASC,OACP,cAAC,IAAD,CAAUJ,MAAOA,EAAjB,SACE,cAAC,EAAD,MAEFK,SAASC,eAAe,W","file":"static/js/main.5a8b0790.chunk.js","sourcesContent":["export const INCREMENT = 'INCREMENT';\nexport const DECREMENT = 'DECREMENT';\n\n// Nuestras actions (action creators) devolverán un paquete de actions que nuestro reducer recibirá. \n// ¿Cómo es el paquete de acción? Tengan en cuenta que el creador de la acción no es en absoluto responsable \n// de manejar ninguna de las lógicas actuales de actualización del store central de Redux.\n// Eso se lo deja al reducer(s).\n\nexport const increment = () => {\n  // Completa la funcion\n  return {\n    type: INCREMENT\n  }\n};\n\nexport const decrement = () => {\n  // Completa la funcion\n  return {\n     type: DECREMENT\n  }\n};","import React, { Component } from \"react\";\nimport { connect } from 'react-redux';\nimport { increment, decrement } from '../actions';\n\nclass Counter extends Component {\n    // Extra Credit\n    incrementIfOdd = () => {\n      //Implementar una función de incremento que sólo aumenta si el valor del contador es impar\n      if(this.props.count % 2 !== 0){\n        this.props.increment();\n      }\n    };\n    // Extra Credit\n    incrementAsync = () => {\n        //  Implementar una función de incremento que aumenta después de esperar un segundo\n        setTimeout(this.props.increment, 1000);\n    };\n\n    render() {\n        // Completa las funciones onClick de los botones\n        // Al hacer clic en estos botones, el recuento debe disminuir o aumentar en consecuencia\n        return (\n            <p>\n                Clickeado: {this.props.count} veces\n                <button onClick={() => {increment}}>\n                    + {/* Incremeta */}\n                </button>\n                <button onClick={() => {decrement }}>\n                    -  {/* Decrementa */}\n                </button>\n                 {/* Si quieres hacer los extra credit puede descomentar las lineas de abajo */}\n                <button onClick={this.incrementIfOdd}>\n                    incrementa si es impar\n                </button>\n                <button onClick={this.incrementAsync}>\n                    Incrementa despues de un segundos\n                </button> \n            </p>\n        );\n    }\n}\n\n// La función mapStateToProps especifica qué porción del árbol de estados necesita recibir este componente.\n// En este caso, dado que nuestro store de redux sólo almacena el valor del contador,\n// este componente recibe el estado completo.\n// Sin embargo, en una aplicación redux más compleja,\n// recibiría sólo las partes relevantes que necesita del objeto de estado.\nconst mapStateToProps = (state) => {\n    return {\n        count: state.count\n    };\n};\n\n// Se llama a la función de connect para que este componente conozca el resto de la arquitectura de redux.\n// Sin esto, este componente es sólo un componente tonto de React.\n//Pasamos todas las funciones que dependen de Redux, junto con el propio componente,\n// para que Redux se dé a conocer a este componente.\nexport default connect(mapStateToProps, { increment, decrement })(Counter);\n","import { INCREMENT, DECREMENT } from '../actions';\n\nconst initialState = {\n  count: 0\n}\n\n// Nuestro reducer que maneja nuestros dos casos de acción incremento y decremento.\n// Recibe el estado de nuestro store, junto con una action creada por nuestro action creator. \n// ¿Qué tiene que hacer el reducer con el contador de cada caso?\nexport default (state = initialState, action) => {\n  switch (action.type) {\n    case INCREMENT:\n    // completa para este caso\n       return {\n         count: state.count + 1\n       }\n    case DECREMENT:\n    // Fill para este otro\n      return {\n        count: state.count - 1\n      }\n    default:\n      return state;\n  }\n};","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { configureStore } from 'redux';\nimport { Provider } from 'react-redux';\nimport Counter from './components/Counter';\nimport counter from './reducers';\n\n// Esta línea instancia nuestro store central de Redux.\n// La función `createStore` recibe el reducer\n// que es responsable de la actualización del store , junto\n//con cualquier estado inicial con el que queramos que\n//empiece el store (que en este caso es ninguno).\nconst store = createStore(counter);\n\n// Aquí, envolvemos nuestro componente principal React dentro de las etiquetas del Provider,\n// que vienen del paquete react-redux.\n// Esto es necesario porque el store necesita saber hacia dónde está pasando su estado. \n// El componente Provider es donde \"vive\" el store.\nReactDOM.render(\n  <Provider store={store}>\n    <Counter />\n  </Provider>,\n  document.getElementById('root')\n);"],"sourceRoot":""}